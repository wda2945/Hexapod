/*
 * Partly Auto-Generated by NUKE!
 *   http://arbotix.googlecode.com
 *
 * Extensively modified by Martin to change input source
 *
 */
#define VOLT_CHECK      //halt if voltage too low
//#define NO_TIMEOUT      //disable message timeout stop
//#define SIMPLE_COMMANDS  //use one letter test commands

#define LOW_VOLTAGE_LIMIT 100

#include <ctype.h>
#include <ax12.h>
#include <BioloidController.h>
#include "nuke.h"
#include "hex_msg.h"    //serial message definitions

#ifdef SIMPLE_COMMANDS
#define DEBUG(t) Serial.println(t);

static char *messageNames[] = DEBUG_MSG_L;
static char *stateNames[] = AX_STATE_NAMES;
static char *legNames[] = LEG_NAMES;
static char *servoNames[] = SERVO_NAMES;

#else
#define DEBUG(t)
#endif

//added functions
void StandUp();
void SitDown();
void TorqueOnAll();
void TorqueOffAll();

//comms responses
void SendMessage(message_t *msg);
void SendTextMessage(char msgType, char *text);
void SendStatus(axState_enum _state);
void SendPose(int legNr, int x, int y, int z);
void SendServos(int legNr, int coxa, int femur, int tibia);
void SendAllServos();
void SendReg(int reg, int val);
void SendOdo(int x, int y, int r);

int CheckVoltage();
int SendVoltage(int volts);
void ErrorMessage(msgType_enum m);
int CheckForServoError();

//gait code extension
void MyGaitSelect(int GaitType);
void FindServoNumbers(char legNumber);

//FK function to determine endpoint from servo angles
ik_req_t legFK(char legNr, int c, int f, int t);

int lowVoltage = false;
int sitHeight = 30;
int sitSpread = 30;

#define RIPPLE_SPEED    1
#define AMBLE_SPEED     3
#define TRIPOD_SPEED    5
#define TOP_SPEED      10

#define MOVING   ((Xspeed >= 1 || Xspeed <= -1) || (Yspeed >= 1 || Yspeed <= -1) || (Rspeed >= 0.01 || Rspeed <= -0.01))

struct ServoStruct {
  int coxa, femur, tibia;
} 
resetServoPositions[6] = {
  { 
    500, 600, 500                                }
  ,        //RF
  { 
    500, 600, 500                                }
  ,        //RR
  { 
    500, 400, 500                                }
  ,        //LF
  { 
    500, 400, 500                                }
  ,        //LR
  { 
    500, 600, 500                                }
  ,        //RM
  { 
    500, 400, 500                                }         //LM
};

int              endOfCycle;    //to flag end of single-shot actions
axState_enum     axStatus = AX_TORQUED;

message_t        message;  //received message

//servo numbers from leg look up
int coxaServo,  femurServo, tibiaServo; 

msgType_enum     lastCommand = MSG_TYPE_NONE;
unsigned long    msgTime;
char             defaultGait;

#define SMART_BASIC_SEL 0  //pin for FTDI Smart Basic Select

void setup()
{
  char volts[5];

  delay(2000);

  pinMode(SMART_BASIC_SEL, OUTPUT);
  digitalWrite(SMART_BASIC_SEL, HIGH);

  // setup IK engine
  bioloid.poseSize = 18;      //18 servos
  bioloid.readPose();         //read pose from servos
  setupIK();
  gaitSelect(AMBLE_SMOOTH);
  defaultGait = AMBLE_SMOOTH;

  // setup serial
  Serial.begin(38400);

  // wait, then check the voltage (LiPO safety)
  delay (1000);
  CheckVoltage();

  if (lowVoltage)
  {
#ifdef SIMPLE_COMMANDS
    Serial.println("Too low");
#endif
#ifdef VOLT_CHECK
    while(lowVoltage)
    {
      delay(5000);
      CheckVoltage();
    }
#endif
  }
  TorqueOffAll();
}

//process any message in the serial buffer
int CheckForMessage()
{
#ifdef SIMPLE_COMMANDS
  if (Serial.available() > 0)
  {
    char cmd = Serial.read();
    //    Serial.print("Status: ");
    //    Serial.println(stateNames[axStatus]);
    switch (cmd)
    {
    case 'U':    //standup
    case 'u':
      message.msgType = MSG_TYPE_STAND;
      return 1;
      break;
    case 'D':    //sitdown
    case 'd':
      message.msgType = MSG_TYPE_SIT;
      return 1;
      break;
    case 'w':
    case 'W':
      message.msgType = MSG_TYPE_WALK;
      message.xSpeed = 50;
      message.ySpeed = 0;
      message.zRotateSpeed = 0;
      message.steps = 10;
      return 1;
      break;   
    case 'T':    //turn
    case 't':
      message.msgType = MSG_TYPE_WALK;
      message.xSpeed = 0;
      message.ySpeed = 0;
      message.zRotateSpeed = 20;
      message.steps = 10;
      return 1;
      break;
    case 'h':
    case 'H':
      message.msgType = MSG_TYPE_HALT;
      return 1;
      break;
    case 'S':    //status
    case 's':
      message.msgType = MSG_TYPE_GETSTATUS;
      return 1;
      break;
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      message.msgType = MSG_TYPE_GET_POSE;
      message.legNumber = cmd - '1';
      return 1; 

      break;
    case 'E':    //status
    case 'e':
      {
        int i;
        for (i=1; i<=18; i++)
        {
          int voltage = (ax12GetRegister (i, AX_PRESENT_VOLTAGE, 1));
          int error = ax12GetLastError();
          Serial.print(i); 
          Serial.print(" = ");
          Serial.println(error, HEX);
        }
      }
      return 0;
      break;
    default:
      message.msgType = MSG_TYPE_NONE;
      return 0;
      break;     
    }
  }
#else
  // check for a whole message in the serial buffer to avoid waits
  if (Serial.available() >= MSG_LEN + 2)  //includes STX & checksum bytes
  {
    if (Serial.read() == MSG_START)    //check and skip STX
    {
      int i;
      int csum = 0;
      unsigned char c;
      unsigned char *cmsg = (unsigned char *) &message;
      for (i=0; i< 8; i++)
      {
        //read the message
        c = Serial.read();
        cmsg[i] = c;
        csum += c;
      }

      message.msgType = Serial.read();
      csum += message.msgType;

      //check checksum
      c = Serial.read();
      if (c == (csum & 0xff))
      {
        return 1;
      }
      else
      {
        message_t msg;
        memset(&msg, 0, MSG_LEN);
        msg.msgType = MSG_TYPE_ERROR;
        msg.errorCode = (unsigned short int) BAD_CHECKSUM;
        msg.errorState = (unsigned short int) axStatus;
        msg.error1 = c;
        msg.error2 = csum;
        SendMessage(&msg);
        //message ignored
      }
    }
  }
#endif
  return 0;
}
void loop(){
  // first take commands
  if (CheckForMessage())
  {
    //received message is in message
    msgTime = millis();

    //check for valid message context
    switch(axStatus)
    {
    case AX_RELAXED:  //torque off
    case AX_TORQUED:    //powered up - sitting down, torqued
      switch (message.msgType) {
      case MSG_TYPE_GAIT:
      case MSG_TYPE_RELAX:      
      case MSG_TYPE_STAND:     //no payload
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_GET_POSE:  //legNumber
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        //not OK
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_READY:  //standing, ready to move
      switch (message.msgType) {
      case MSG_TYPE_GAIT:
      case MSG_TYPE_HALT:      //no payload
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_WALK:      //walk payload
      case MSG_TYPE_BODY:      //x:y:z payload
      case MSG_TYPE_ROTATE:    //x:y:z payload (z not used)
      case MSG_TYPE_SIT:        //no payload
      case MSG_TYPE_POSEMODE:   //no payload
      case MSG_TYPE_GET_POSE:  //legNumber
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_WALKING:
      switch (message.msgType) {
      case MSG_TYPE_HALT:      //no payload
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_WALK:      //walk payload
      case MSG_TYPE_BODY:      //x:y:z payload
      case MSG_TYPE_ROTATE:    //x:y:z payload (z not used)
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_STOPPING:
    case AX_SITTING:
    case AX_STANDING:
    case AX_POSING:
      switch (message.msgType) {
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_POSE_READY:
      switch (message.msgType) {
      case MSG_TYPE_GAIT:
      case MSG_TYPE_HALT:      //no payload
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_WALK:      //walk payload
      case MSG_TYPE_BODY:      //x:y:z payload
      case MSG_TYPE_ROTATE:    //x:y:z payload (z not used)
      case MSG_TYPE_SIT:        //no payload      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_GET_POSE:  //legNumber
      case MSG_TYPE_SET_SERVOS: //servos payload
      case MSG_TYPE_SET_POSE:  //set pose payload
      case MSG_TYPE_POSEMODE:   //no payload
      case MSG_TYPE_MOVE:      //no payload
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    }  //end of context switch  

    //if we get here, the command can be processed
    //process the command
    switch (message.msgType) {
    case MSG_TYPE_HALT:
      Xspeed = Yspeed = Rspeed = 0;
      if (axStatus == AX_WALKING)
      {
        SendStatus(AX_STOPPING); 
      }    
      break;
    case MSG_TYPE_GETSTATUS:
      SendStatus(axStatus);
      CheckForServoError();
      break;
    case MSG_TYPE_WALK:
      {
        Xspeed = message.xSpeed;      //mm per sec
        Yspeed = message.ySpeed;      //mm per sec
        Rspeed = 3.14159f * message.zRotateSpeed / 180.0f;    //degrees per sec to radians per sec
        if (MOVING)
        {
          //calculate speed factors
          int maxSpeed  = max(abs(Xspeed), abs(Yspeed));    //start with the higher speed
          if (maxSpeed > 50) maxSpeed = 50;
          int nomStride = (30 + maxSpeed);                  //take a starting stride length (30 - 80mm)
          //TODO: Tune this
          float nomCycleTime;                               //seconds
          if (maxSpeed == 0)
          {
            nomCycleTime = 2.0;                            //turn only
          }
          else
          {
            nomCycleTime = (nomStride * stepsInCycle)     
              / (maxSpeed * pushSteps);                              //cycletime ignoring BIOLOID_FRAME_LENGTH
          }
          float nomTranTime = nomCycleTime * 1000.0 / stepsInCycle;  //step transition time ignoring BIOLOID_FRAME_LENGTH
          int kFactor = (nomTranTime + 1) / 33;                     //round the k factor to an integer

          tranTime = (kFactor * 33) -1;                            //available transition time
          cycleTime = (tranTime * stepsInCycle) / 1000.0;          //corresponding cycle time in seconds

#ifdef SIMPLE_COMMANDS
          Serial.print("nomCycleTime ");
          Serial.println(nomCycleTime);
          Serial.print("nomTranTime ");
          Serial.println(nomTranTime);

          Serial.print("tranTime ");
          Serial.println(tranTime);
          Serial.print("cycleTime ");
          Serial.println(cycleTime);
#endif
          SendStatus(AX_WALKING);
        }
      }
      break;
    case MSG_TYPE_BODY:    //body movement in X & Y
      bodyPosX = message.xBody;
      bodyPosY = message.yBody;
      break;
    case MSG_TYPE_ROTATE:  //body rotation in X, Y, & Z
      bodyRotX = ((float) message.xBody) / 300.0;    // body roll
      bodyRotY = ((float) message.yBody) / 300.0;    // body pitch
      bodyRotZ = ((float) message.zBody) / 300.0;    // body yaw
      break;
    case MSG_TYPE_GAIT:
      if (message.gait < 0x10) {
        //regular gaits
        gaitSelect(message.gait);
      }
      else 
      {
        //special moves tbd
        MyGaitSelect(message.gait);
      }
      break;
    case MSG_TYPE_TORQUE:    //servos on
      {
        TorqueOnAll();
      }
      break;
    case MSG_TYPE_RELAX:    //relax servos
      TorqueOffAll();
      break;
    case MSG_TYPE_STAND:
      {
        StandUp();
      }
      break;  
    case MSG_TYPE_SIT:
      SitDown();
      break;  
    case MSG_TYPE_POSEMODE:      //switch to pose mode
      bodyPosX = 0.0;
      bodyPosY = 0.0;
      bodyRotX = 0.0;
      bodyRotY = 0.0;
      bodyRotZ = 0.0;
      SendStatus(AX_POSE_READY);
      break; 
    case MSG_TYPE_GET_POSE:  //obtain current x,y,z for a leg  
      {
        ik_sol_t servos;    //used as FK input here
        ik_req_t pose;      //used as FK output here
        FindServoNumbers(message.legNumber);
        servos.coxa = bioloid.getCurPose(coxaServo);
        servos.femur = bioloid.getCurPose(femurServo);
        servos.tibia = bioloid.getCurPose(tibiaServo);
        pose = legFK(message.legNumber, servos.coxa,servos.femur,servos.tibia );
        SendServos(message.legNumber, servos.coxa, servos.femur, servos.tibia);
        SendPose(message.legNumber, pose.x, pose.y, pose.z);
      }
      break;
    case MSG_TYPE_SET_POSE:  //specify next x,y,z for a leg
      {
        int servo, servoCoxa, servoFemur, servoTibia;
        ik_req_t req;
        ik_sol_t sol;
        endpoints[message.legNumber].x = message.x;
        endpoints[message.legNumber].y = message.y;
        endpoints[message.legNumber].z = message.z;

        switch(message.legNumber)
        {
        case RIGHT_FRONT:
          // right front leg

          req = bodyFK(endpoints[RIGHT_FRONT].x, endpoints[RIGHT_FRONT].y,  endpoints[RIGHT_FRONT].z, 
                X_COXA, Y_COXA, 0);          //body
          sol = legIK(endpoints[RIGHT_FRONT].x+req.x, endpoints[RIGHT_FRONT].y+req.y, endpoints[RIGHT_FRONT].z+req.z);
          servoCoxa = servo = 368 + sol.coxa;
          if(servo < maxs[RF_COXA-1] && servo > mins[RF_COXA-1])
            bioloid.setNextPose(RF_COXA, servo);
          else{
            ServoFail(RFC, servo);
          }
          servoFemur = servo = 524 + sol.femur;
          if(servo < maxs[RF_FEMUR-1] && servo > mins[RF_FEMUR-1])
            bioloid.setNextPose(RF_FEMUR, servo);
          else{
            ServoFail(RFF, servo);
          }
          servoTibia = servo = 354 + sol.tibia;
          if(servo < maxs[RF_TIBIA-1] && servo > mins[RF_TIBIA-1])
            bioloid.setNextPose(RF_TIBIA, servo);
          else{
            ServoFail(RFT, servo);
          }
          break;
        case RIGHT_REAR:
          // right rear leg
          req = bodyFK(endpoints[RIGHT_REAR].x, endpoints[RIGHT_REAR].y, endpoints[RIGHT_REAR].z, 
              -X_COXA, Y_COXA, 0);
          sol = legIK(-endpoints[RIGHT_REAR].x-req.x, endpoints[RIGHT_REAR].y+req.y, endpoints[RIGHT_REAR].z+req.z);
          servoCoxa = servo = 656 - sol.coxa;
          if(servo < maxs[RR_COXA-1] && servo > mins[RR_COXA-1])
            bioloid.setNextPose(RR_COXA, servo);
          else{
            ServoFail(RRC, servo);
          }
          servoFemur = servo = 524 + sol.femur;
          if(servo < maxs[RR_FEMUR-1] && servo > mins[RR_FEMUR-1])
            bioloid.setNextPose(RR_FEMUR, servo);
          else{
            ServoFail(RRF, servo);
          }
          servoTibia = servo = 354 + sol.tibia;
          if(servo < maxs[RR_TIBIA-1] && servo > mins[RR_TIBIA-1])
            bioloid.setNextPose(RR_TIBIA, servo);
          else{
            ServoFail(RRT, servo);
          }
          break;
        case LEFT_FRONT:
          // left front leg
          req = bodyFK(endpoints[LEFT_FRONT].x, endpoints[LEFT_FRONT].y, endpoints[LEFT_FRONT].z, 
              X_COXA, -Y_COXA, 0);
          sol = legIK(endpoints[LEFT_FRONT].x+req.x, -endpoints[LEFT_FRONT].y-req.y, endpoints[LEFT_FRONT].z+req.z);
          servoCoxa = servo = 656 - sol.coxa;
          if(servo < maxs[LF_COXA-1] && servo > mins[LF_COXA-1])
            bioloid.setNextPose(LF_COXA, servo);
          else{
            ServoFail(LFC, servo);
          }
          servoFemur = servo = 500 - sol.femur;
          if(servo < maxs[LF_FEMUR-1] && servo > mins[LF_FEMUR-1])
            bioloid.setNextPose(LF_FEMUR, servo);
          else{
            ServoFail(LFF, servo);
          }
          servoTibia = servo = 670 - sol.tibia;
          if(servo < maxs[LF_TIBIA-1] && servo > mins[LF_TIBIA-1])
            bioloid.setNextPose(LF_TIBIA, servo);
          else{
            ServoFail(LFT, servo);
          }
          break;
        case LEFT_REAR:
          // left rear leg
          req = bodyFK(endpoints[LEFT_REAR].x, endpoints[LEFT_REAR].y,  endpoints[LEFT_REAR].z, 
              -X_COXA, -Y_COXA, 0);
          sol = legIK(-endpoints[LEFT_REAR].x-req.x, -endpoints[LEFT_REAR].y-req.y, endpoints[LEFT_REAR].z+req.z);
          servoCoxa = servo = 368 + sol.coxa;
          if(servo < maxs[LR_COXA-1] && servo > mins[LR_COXA-1])
            bioloid.setNextPose(LR_COXA, servo);
          else{
            ServoFail(LRC, servo);
          }
          servoFemur = servo = 500 - sol.femur;
          if(servo < maxs[LR_FEMUR-1] && servo > mins[LR_FEMUR-1])
            bioloid.setNextPose(LR_FEMUR, servo);
          else{
            ServoFail(LRF, servo);
          }
          servoTibia = servo = 670 - sol.tibia;
          if(servo < maxs[LR_TIBIA-1] && servo > mins[LR_TIBIA-1])
            bioloid.setNextPose(LR_TIBIA, servo);
          else{
            ServoFail(LRT, servo);
          }
          break;
        case RIGHT_MIDDLE:
          // right middle leg
          req = bodyFK(endpoints[RIGHT_MIDDLE].x, endpoints[RIGHT_MIDDLE].y,  endpoints[RIGHT_MIDDLE].z, 
              0, Y_COXA, 0);
          sol = legIK(endpoints[RIGHT_MIDDLE].x+req.x, endpoints[RIGHT_MIDDLE].y+req.y, endpoints[RIGHT_MIDDLE].z+req.z);
          servoCoxa = servo = 512 + sol.coxa;
          if(servo < maxs[RM_COXA-1] && servo > mins[RM_COXA-1])
            bioloid.setNextPose(RM_COXA, servo);
          else{
            ServoFail(RMC, servo);
          }
          servoFemur = servo = 524 + sol.femur;
          if(servo < maxs[RM_FEMUR-1] && servo > mins[RM_FEMUR-1])
            bioloid.setNextPose(RM_FEMUR, servo);
          else{
            ServoFail(RMF, servo);
          }
          servoTibia = servo = 354 + sol.tibia;
          if(servo < maxs[RM_TIBIA-1] && servo > mins[RM_TIBIA-1])
            bioloid.setNextPose(RM_TIBIA, servo);
          else{
            ServoFail(RMT, servo);
          }
          break;
        case LEFT_MIDDLE:
          // left middle leg
          req = bodyFK(endpoints[LEFT_MIDDLE].x, endpoints[LEFT_MIDDLE].y, endpoints[LEFT_MIDDLE].z, 
              0, -Y_COXA, 0);
          sol = legIK(endpoints[LEFT_MIDDLE].x+req.x, -endpoints[LEFT_MIDDLE].y-req.y, endpoints[LEFT_MIDDLE].z+req.z);
          servoCoxa = servo = 512 - sol.coxa;
          if(servo < maxs[LM_COXA-1] && servo > mins[LM_COXA-1])
            bioloid.setNextPose(LM_COXA, servo);
          else{
            ServoFail(LMC, servo);
          }
          servoFemur = servo = 500 - sol.femur;
          if(servo < maxs[LM_FEMUR-1] && servo > mins[LM_FEMUR-1])
            bioloid.setNextPose(LM_FEMUR, servo);
          else{
            ServoFail(LMF, servo);
          }
          servoTibia = servo = 670 - sol.tibia;
          if(servo < maxs[LM_TIBIA-1] && servo > mins[LM_TIBIA-1])
            bioloid.setNextPose(LM_TIBIA, servo);
          else{
            ServoFail(LMT, servo);
          }

          break;
        }

        SendServos(message.legNumber, servoCoxa, servoFemur, servoTibia);
      }
      break;
    case MSG_TYPE_SET_SERVOS:
      {
        ik_sol_t servos;    //used as FK input here
        ik_req_t pose;      //used as FK output here
        servos.coxa = message.coxa;
        servos.femur = message.femur;
        servos.tibia = message.tibia;
        FindServoNumbers(message.legNumber);
        bioloid.setNextPose(coxaServo, servos.coxa);
        bioloid.setNextPose(femurServo, servos.femur);
        bioloid.setNextPose(tibiaServo, servos.tibia);
        pose = legFK(message.legNumber, servos.coxa,servos.femur,servos.tibia );
        SendPose(message.legNumber, pose.x, pose.y, pose.z);
      }
      break;
    case MSG_TYPE_MOVE:      //go to next pose
      {
        int kFactor = (message.time + 1) / 33;       //round the k factor to an integer
        tranTime = (kFactor * 33) -1; 
        bioloid.interpolateSetup(tranTime);
        SendStatus(AX_POSING);
      }
      break; 
    case MSG_TYPE_READ_REG:
      {
        int reg = ax12GetRegister(message.regReadId, message.regReadStart, message.regReadLength);
        SendReg(message.regReadStart, reg); 
      }
      break;
    case MSG_TYPE_WRITE_REG:
      ax12SetRegister(message.regWriteId, message.regWriteStart, message.regWriteL);
      break;
    case MSG_TYPE_WRITE_REG2:
      ax12SetRegister2(message.regWriteId, message.regWriteStart, (message.regWriteH << 8) + message.regWriteL);
      break;
    default:
      ErrorMessage(MSG_TYPE_UNKNOWN);
      break;
    } //end of command switch

  }
  else
  {
#ifndef NO_TIMEOUT
    if (msgTime + 5000 < millis() && axStatus == AX_WALKING)
    {
      //timeout after 5 seconds
      Xspeed = Yspeed = Rspeed = 0;
      ErrorMessage(NOMSG_TIMEOUT);
      SendStatus(AX_STOPPING);
    } 
#endif
  }
  //interpolate as needed
  switch (axStatus)
  {
  case AX_WALKING:
    {
      // if our previous interpolation is complete, recompute the IK
      if(bioloid.interpolating == 0){
        doIK();
        bioloid.interpolateSetup(tranTime);
      }
      // update joints
      bioloid.interpolateStep();
    }
    break;
  case AX_STOPPING:
    {
      // if our previous interpolation is complete, recompute the IK
      if(bioloid.interpolating == 0){
        if (endOfCycle)
        {
          gaitSelect(defaultGait);
          SendStatus(AX_READY);
        }
        else
        {
          doIK();
          bioloid.interpolateSetup(tranTime);
        }
      }
      else
      {
        // update joints
        bioloid.interpolateStep();
      }
    }
    break;

  case AX_SITTING:  //in process
    {
      // if our previous interpolation is complete, recompute the IK
      if(bioloid.interpolating == 0){
        if (endOfCycle)
        {
          gaitSelect(defaultGait);
          TorqueOffAll();
        }
        else
        {
          doIK();
          bioloid.interpolateSetup(tranTime);
        }
      }
      else
      {
        // update joints
        bioloid.interpolateStep();
      }
    }
    break;
  case AX_STANDING:
    {
      // if our previous interpolation is complete, recompute the IK
      if(bioloid.interpolating == 0){
        if (endOfCycle)
        {
          gaitSelect(defaultGait);
          SendStatus(AX_READY);
        }
        else
        {
          doIK();
          bioloid.interpolateSetup(tranTime);
        }
      }
      else
      {
        // update joints
        bioloid.interpolateStep();
      }
    }
    break;
  case AX_POSING:
    if (bioloid.interpolating != 0){
      bioloid.interpolateStep();
    }
    else
    {
      SendStatus(AX_POSE_READY);
    }
    break;
  case AX_READY:
    CheckForServoError();
    break;
  default:
    break;
  }
}

int EndOfStep()
{
  DEBUG(stepNumber);
  if (axStatus == AX_WALKING)
  {
    SendOdo(((Xspeed*cycleTime)/stepsInCycle), ((Yspeed*cycleTime)/stepsInCycle), ((180.0*Rspeed*cycleTime)/(3.14159f*stepsInCycle)));

    if (--message.steps <= 0)
    {
      DEBUG("stopping");
      Xspeed = Yspeed = Rspeed = 0;
      SendStatus(AX_STOPPING);
    }
  }

  endOfCycle = (stepNumber == 0 ? 1 : 0);

  return 0;
}

// stand up slowly
void StandUp()
{
  TorqueOnAll();
  bioloid.readPose();
  MyGaitSelect(STANDUP);
  doIK();
  bioloid.interpolateSetup(tranTime);
  SendStatus(AX_STANDING);
}
// sit down slowly
void SitDown()
{
  SendStatus(AX_SITTING);
  MyGaitSelect(SITDOWN);
  doIK();
  bioloid.interpolateSetup(tranTime);
}
// resume stance
void Stance()
{
  SendStatus(AX_STOPPING);
  MyGaitSelect(STANCE);
  doIK();
  bioloid.interpolateSetup(tranTime);
}
//prep to stand
void TorqueOnAll()
{
  int i;
  for (i=1; i<=18; i++)
  {
    SetPosition(i, GetPosition(i));
    TorqueOn(i);
  }
  bioloid.readPose();
  SendStatus(AX_TORQUED);
}
//relax
void TorqueOffAll()
{
  int i;
  for (i=1; i<=18; i++)
  {
    Relax(i);
  }
  SendStatus(AX_RELAXED);
}
//lookup servo numbers for leg
void FindServoNumbers(char legNumber)
{
  switch (legNumber) {
  case RF:
    coxaServo  = RF_COXA;
    femurServo = RF_FEMUR;
    tibiaServo = RF_TIBIA;
    break;
  case RR:
    coxaServo  = RR_COXA;
    femurServo = RR_FEMUR;
    tibiaServo = RR_TIBIA;
    break;
  case LF:
    coxaServo  = LF_COXA;
    femurServo = LF_FEMUR;
    tibiaServo = LF_TIBIA;
    break;
  case LR:
    coxaServo  = LR_COXA;
    femurServo = LR_FEMUR;
    tibiaServo = LR_TIBIA;
    break;
  case RM:
    coxaServo  = RM_COXA;
    femurServo = RM_FEMUR;
    tibiaServo = RM_TIBIA;
    break;
  case LM:
    coxaServo  = LM_COXA;
    femurServo = LM_FEMUR;
    tibiaServo = LM_TIBIA;
    break;
  default:
#ifdef SIMPLE_COMMANDS
    Serial.print("Bad Leg#: ");
    Serial.println(legNumber);
#endif
    coxaServo  = 0;
    femurServo = 0;
    tibiaServo = 0;
    break; 
  }
}

//Communications functions

void SendAllServos()
{
  int i;
  bioloid.poseSize = 18;
  bioloid.readPose();
  for (i = 0; i<6; i++)
  {
    ik_sol_t servos;
    FindServoNumbers(i);
    servos.coxa = bioloid.getCurPose(coxaServo);
    servos.femur = bioloid.getCurPose(femurServo);
    servos.tibia = bioloid.getCurPose(tibiaServo);
    SendServos(i, servos.coxa, servos.femur, servos.tibia);
  } 
}
//send text message
void SendTextMessage(unsigned char msgType, char *textMsg)
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = msgType;
  strncpy((char*) msg.text, textMsg, TEXT_LEN);
  SendMessage(&msg);
}

//send servo out of range fail
void ServoFail(servo_enum servo, int angle)
{
#ifdef SIMPLE_COMMANDS
  Serial.print("Servo Fail: #");
  Serial.print(servo);
  Serial.print(", Angle= ");
  Serial.println(angle);
#else 
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_FAIL;
  msg.servo = servo;
  msg.angle = angle;
  SendMessage(&msg);
#endif
}

//send status report
void SendStatus(axState_enum _state)
{
  axStatus = _state;
#ifdef SIMPLE_COMMANDS
  Serial.print("Status = ");
  Serial.print(stateNames[axStatus]);
  Serial.print(" Interpolating = ");
  Serial.println(bioloid.interpolating);
#else  
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_STATUS;
  msg.state = axStatus;
  msg.lastCommand = lastCommand;
  msg.busy = (bioloid.interpolating ? 1 : 0);
  SendMessage(&msg);
#endif
}

int CheckForServoError()
{
  int i;
  for (i=1; i<=18; i++)
  {
    int voltage = (ax12GetRegister (i, AX_PRESENT_VOLTAGE, 1));  //access something
    unsigned short int error = ax12GetLastError() & 0xff;

    if (error != 0)
    {
#ifdef SIMPLE_COMMANDS
      Serial.print("Servo ");
      Serial.print(servoNames[i-1]);
      Serial.print(" error = ");
      Serial.println(error);
#else 
      message_t msg;
      memset(&msg, 0, MSG_LEN);
      msg.msgType = MSG_TYPE_ERROR;
      msg.errorCode = (unsigned short int) SERVO_ERROR;
      msg.errorState = (unsigned short int) axStatus;
      msg.error1 = i;
      msg.error2 = error;
      SendMessage(&msg);
#endif
    }    
  }  
}


//send leg pose
void SendPose(int legNr, int x, int y, int z)
{
#ifdef SIMPLE_COMMANDS
  Serial.print(legNr);
  Serial.print(" (");
  Serial.print(legNames[legNr]);
  Serial.print("): X= ");
  Serial.print(x);
  Serial.print(", Y= ");
  Serial.print(y);
  Serial.print(", Z= ");
  Serial.println(z);
#else 
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_POSE;
  msg.legNumber = legNr;
  msg.x = x;
  msg.y = y;
  msg.z = z;
  SendMessage(&msg);
#endif
}

//send leg servos
void SendServos(int legNr, int coxa, int femur, int tibia)
{
#ifdef SIMPLE_COMMANDS
  Serial.print(legNr);
  Serial.print(" (");
  Serial.print(legNames[legNr]);
  Serial.print("): Coxa= ");
  Serial.print(coxa);
  Serial.print(", Femur= ");
  Serial.print(femur);
  Serial.print(", Tibia= ");
  Serial.println(tibia);
#else  
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_SERVOS;
  msg.legNumber = legNr;
  msg.coxa = coxa;
  msg.femur = femur;
  msg.tibia = tibia;
  SendMessage(&msg);
#endif
}

//send reg value
void SendReg(int reg, int val)
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_REG;
  msg.ax12Reg = val;
  SendMessage(&msg);
}

void SendOdo(int x, int y, int r)
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_ODOMETRY;
  msg.xMovement = x;    //mm
  msg.yMovement = y;    //mm
  msg.zRotation = r;    //degrees
  SendMessage(&msg);
}

void SendMessage(message_t *msg)
{
  int i;
  int csum = 0;
  unsigned char *cMsg = (unsigned char *)msg;
#ifdef SIMPLE_COMMANDS
  Serial.print("Message: ");
  Serial.print(messageNames[msg->msgType]);
  for (i=0; i<MSG_INTS; i++)
  {
    Serial.print(", ");
    Serial.print(msg->intValues[i]);
  }
  Serial.println();
#else

  Serial.write(MSG_START);
  for (i=0; i<MSG_LEN; i++)
  {
    Serial.write(cMsg[i]);
    csum += cMsg[i];
  }
#ifndef NO_CRC
  Serial.write(csum & 0xff);
#endif
#endif
}

int CheckVoltage()
{
  int voltage = (ax12GetRegister (1, AX_PRESENT_VOLTAGE, 1));
  if (voltage < LOW_VOLTAGE_LIMIT)
  {
    lowVoltage = true;
    ErrorMessage(LOW_VOLTAGE);
    SendVoltage(voltage);
  }
  else
  {
    lowVoltage = false;
  }
  return voltage;
}
//send voltage
int SendVoltage(int voltage)
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
#ifdef SIMPLE_COMMANDS
  Serial.print("Voltage: ");
  Serial.println((float)voltage/10);
#else
  msg.msgType = MSG_TYPE_VOLTS;
  msg.volts = voltage & 0xff;
  SendMessage(&msg);
#endif
  return voltage;
}

void ErrorMessage(msgType_enum m)
{
#ifdef SIMPLE_COMMANDS
  Serial.print("Error: ");
  Serial.println(messageNames[m]);
  Serial.print("State: ");
  Serial.println(stateNames[axStatus]);
#else
  message_t msg;
  memset(&msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_ERROR;
  msg.errorCode = (unsigned short int) m;
  msg.errorState = (unsigned short int) axStatus;
  SendMessage(&msg);
#endif
}













