/*
 * Partly Auto-Generated by NUKE!
 *   http://arbotix.googlecode.com
 *
 * Extensively modified by Martin to change input source
 *
 */
#define VOLT_CHECK      //halt if voltage too low
#define NO_TIMEOUT      //disable message timeout stop
//#define SIMPLE_COMMANDS  //use one letter test commands

#include <ctype.h>
#include <ax12.h>
#include <BioloidController.h>
#include "nuke.h"
#include "hex_msg.h"    //serial message definitions

#ifdef SIMPLE_COMMANDS
static char *messageNames[] = DEBUG_MSG_L;
static char *stateNames[] = AX_STATE_NAMES;
static char *legNames[] = LEG_NAMES;
#endif

//added functions
void StandUp();
void SitDown();
void TorqueOnAll();
void TorqueOffAll();

//comms responses
void SendMessage(message_t *msg);
void SendTextMessage(char msgType, char *text);
void SendStatus(axState_enum _state);
void SendPose(int legNr, int x, int y, int z);
void SendServos(int legNr, int coxa, int femur, int tibia);
void SendAllServos();
void SendReg(int reg, int val);
void SendOdo(int x, int y, int r);

int CheckVoltage();
int SendVoltage();
void ErrorMessage(msgType_enum m);

//gait code extension
void MyGaitSelect(int GaitType);
void FindServoNumbers(char legNumber);
//FK function to determine endpoint from servo angles
ik_req_t legFK(char legNr, int c, int f, int t);

int lowVoltage = false;
int sitHeight = 30;
int sitSpread = 30;

#define RIPPLE_SPEED    1
#define AMBLE_SPEED     3
#define TRIPOD_SPEED    5
#define TOP_SPEED      10

#define MOVING   ((Xspeed >= 1 || Xspeed <= -1) || (Yspeed >= 1 || Yspeed <= -1) || (Rspeed >= 0.01 || Rspeed <= -0.01))

struct ServoStruct {
  int coxa, femur, tibia;
} 
resetServoPositions[6] = {
  { 
    500, 600, 500                    }
  ,        //RF
  { 
    500, 600, 500                    }
  ,        //RR
  { 
    500, 400, 500                    }
  ,        //LF
  { 
    500, 400, 500                    }
  ,        //LR
  { 
    500, 600, 500                    }
  ,        //RM
  { 
    500, 400, 500                    }         //LM
};

int              endOfCycle;    //to flag end of single-shot actions
axState_enum     axStatus = AX_TORQUED;

message_t        message;  //received message

//servo numbers from leg look up
int coxaServo,  femurServo, tibiaServo; 

msgType_enum     lastCommand = MSG_TYPE_NONE;
unsigned long    msgTime;
char             defaultGait;

void setup()
{
  message_t msg;
  char volts[5];

  pinMode(0,OUTPUT);
  delay(100);
  
  // setup IK engine
  bioloid.poseSize = 18;
  bioloid.readPose();
  setupIK();
  gaitSelect(AMBLE_SMOOTH);
  defaultGait = AMBLE_SMOOTH;

  // setup serial
  Serial.begin(38400);

  // wait, then check the voltage (LiPO safety)
  delay (1000);
  SendVoltage();

  if (lowVoltage)
  {
#ifdef SIMPLE_COMMANDS
    Serial.println("Too low");
#endif
#ifdef VOLT_CHECK
    while(lowVoltage)
    {
      delay(5000);
      ErrorMessage(LOW_VOLTAGE);
      SendVoltage();
    }
#endif
  }
  SendStatus(AX_TORQUED);
}
int CheckForMessage()
{
#ifdef SIMPLE_COMMANDS
  if (Serial.available() > 0)
  {
    char cmd = Serial.read();
    //    Serial.print("Status: ");
    //    Serial.println(stateNames[axStatus]);
    switch (cmd)
    {
    case 'U':    //standup
    case 'u':
      message.msgType = MSG_TYPE_STAND;
      return 1;
      break;
    case 'D':    //sitdown
    case 'd':
      message.msgType = MSG_TYPE_SIT;
      return 1;
      break;
    case 'w':
    case 'W':
      message.msgType = MSG_TYPE_WALK;
      message.xSpeed = 50;
      message.ySpeed = 0;
      message.zRotateSpeed = 0;
      return 1;
      break;   
    case 'T':    //turn
    case 't':
      message.msgType = MSG_TYPE_WALK;
      message.xSpeed = 0;
      message.ySpeed = 0;
      message.zRotateSpeed = 20;
      return 1;
      break;
    case 'h':
    case 'H':
      message.msgType = MSG_TYPE_HALT;
      return 1;
      break;
    case 'S':    //status
    case 's':
      message.msgType = MSG_TYPE_GETSTATUS;
      return 1;
      break;
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      message.msgType = MSG_TYPE_GET_POSE;
      message.legNumber = cmd - '1';
      return 1; 

      break;
    default:
      message.msgType = MSG_TYPE_NONE;
      return 0;
      break;     
    }
  }
#else
  // check for a whole message in the serial buffer to avoid waits
  if (Serial.available() >= MSG_LEN + 2)  //includes STX & checksum bytes
  {
    if (Serial.read() == MSG_START)    //check and skip STX
    {
      int i;
      int csum = 0;
      char c;
      unsigned char *cmsg = (unsigned char *) &message;
      for (i=0; i< MSG_LEN; i++)
      {
        //read the message
        c = Serial.read();
        cmsg[i] = c;
        csum += c;
      }
      //check checksum
      if (Serial.read() == (csum & 0xff))
      {
        return 1;
      }
      else
      {
        ErrorMessage(BAD_CHECKSUM);    //message ignored
      }
    }
  }
#endif
  return 0;
}
void loop(){
  // first take commands
  if (CheckForMessage())
  {
    msgTime = millis();
    //check for valid message context
    switch(axStatus)
    {
    case AX_RELAXED:  //torque off
      switch (message.msgType) {
      case MSG_TYPE_GETSTATUS:          
      case MSG_TYPE_GAIT:
      case MSG_TYPE_TORQUE:	  //no payload
      case MSG_TYPE_GET_POSE:  //legNumber
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_TORQUED:    //powered up - sitting down, torqued
      switch (message.msgType) {
      case MSG_TYPE_GAIT:
      case MSG_TYPE_RELAX:      
      case MSG_TYPE_STAND:     //no payload
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_POSE:      //no payload
      case MSG_TYPE_GET_POSE:  //legNumber
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        //not OK
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_READY:  //standing, ready to move
      switch (message.msgType) {
      case MSG_TYPE_GAIT:
      case MSG_TYPE_HALT:      //no payload
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_WALK:      //walk payload
      case MSG_TYPE_BODY:      //x:y:z payload
      case MSG_TYPE_ROTATE:    //x:y:z payload (z not used)
      case MSG_TYPE_SIT:        //no payload
      case MSG_TYPE_POSE:      //no payload
      case MSG_TYPE_GET_POSE:  //legNumber
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_WALKING:
      switch (message.msgType) {
      case MSG_TYPE_HALT:      //no payload
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_WALK:      //walk payload
      case MSG_TYPE_BODY:      //x:y:z payload
      case MSG_TYPE_ROTATE:    //x:y:z payload (z not used)
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_STOPPING:
    case AX_SITTING:
    case AX_STANDING:
      switch (message.msgType) {
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_POSING:
      switch (message.msgType) {
      case MSG_TYPE_HALT:      //no payload
      case MSG_TYPE_GAIT:
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_GET_POSE:  //legNumber
      case MSG_TYPE_SET_SERVOS: //servos payload
      case MSG_TYPE_SET_POSE:  //set pose payload
      case MSG_TYPE_MOVE:      //no payload
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    }  //end of context switch  

    //if we get here, the command can be processed
    //process the command
    switch (message.msgType) {
    case MSG_TYPE_HALT:
      Xspeed = Yspeed = Rspeed = 0;
      if (axStatus == AX_WALKING)
      {
        SendStatus(AX_STOPPING);
      }
      else
      {
        SendStatus(AX_READY);
      }      
      break;
    case MSG_TYPE_GETSTATUS:
      SendStatus(axStatus);
      break;
    case MSG_TYPE_WALK:
      if (lowVoltage)
      {
        ErrorMessage(LOW_VOLTAGE);
        SendVoltage();
      }
      else
      {
        Xspeed = message.xSpeed;      //mm per sec
        Yspeed = message.ySpeed;      //mm per sec
        Rspeed = 3.14159f * message.zRotateSpeed / 180.0f;    //radians per sec
        Serial.print("Rspeed ");
        Serial.println(Rspeed);
        if (!MOVING)
        { 
          if (axStatus == AX_WALKING)
          {
            SendStatus(AX_STOPPING);
          }
          else
          {
            SendStatus(AX_READY);
          } 
        }
        else
        {
          //calculate speed factors
          int maxSpeed  = abs(max(Xspeed, Yspeed));                //start with the higher speed
          if (maxSpeed > 50) maxSpeed = 50;
          int nomStride = (30 + maxSpeed);                //take a starting stride length (30 - 80mm)
          //TODO: Tune this
          float nomCycleTime;
          if (maxSpeed == 0)
          {
            nomCycleTime = 2.0;
          }
          else
          {
            nomCycleTime = (nomStride * stepsInCycle)     
            / (maxSpeed * pushSteps);          //cycletime ignoring BIOLOID_FRAME_LENGTH
          }
          float nomTranTime = nomCycleTime * 1000.0 / stepsInCycle;  //transition time ignoring BIOLOID_FRAME_LENGTH
          int kFactor = (nomTranTime + 1) / 33;                     //round the k factor to an integer

          tranTime = (kFactor * 33) -1;                            //available transition time
          cycleTime = (tranTime * stepsInCycle) / 1000.0;          //corresponding cycle time

      Serial.print("nomCycleTime ");
        Serial.println(nomCycleTime);
        Serial.print("nomTranTime ");
        Serial.println(nomTranTime);
 

       Serial.print("tranTime ");
        Serial.println(tranTime);
        Serial.print("cycleTime ");
        Serial.println(cycleTime);
 
          SendStatus(AX_WALKING);
        }
      }
      break;
    case MSG_TYPE_BODY:    //body movement in X & Y
      bodyPosX = message.xBody;
      bodyPosY = message.yBody;
      break;
    case MSG_TYPE_ROTATE:  //body rotation in X, Y, & Z
      bodyRotX = ((float) message.xBody) / 300.0;    // body roll
      bodyRotY = ((float) message.yBody) / 300.0;    // body pitch
      bodyRotZ = ((float) message.zBody) / 300.0;    // body yaw
      break;
    case MSG_TYPE_GAIT:
      if (message.gait < 0x10) {
        //regular gaits
        gaitSelect(message.gait);
      }
      else 
      {
        //special moves tbd
        MyGaitSelect(message.gait);
      }
      break;
    case MSG_TYPE_TORQUE:    //servos on
      if (lowVoltage)
      {
        ErrorMessage(LOW_VOLTAGE);
        SendVoltage();
      }
      else
      {
        TorqueOnAll();
      }
      break;
    case MSG_TYPE_RELAX:    //relax servos
      TorqueOffAll();
      break;
    case MSG_TYPE_STAND:
      if (lowVoltage)
      {
        ErrorMessage(LOW_VOLTAGE);
        SendVoltage();
      }
      else
      {
        StandUp();
      }
      break;  
    case MSG_TYPE_SIT:
      SitDown();
      break;  
    case MSG_TYPE_POSEMODE:      //switch to pose mode
      SendStatus(AX_POSING);
      break; 
    case MSG_TYPE_GET_POSE:  //obtain current x,y,z for a leg  
      {
        ik_sol_t servos;    //used as FK input here
        ik_req_t pose;      //used as FK output here
        FindServoNumbers(message.legNumber);
        servos.coxa = bioloid.getCurPose(coxaServo);
        servos.femur = bioloid.getCurPose(femurServo);
        servos.tibia = bioloid.getCurPose(tibiaServo);
        pose = legFK(message.legNumber, servos.coxa,servos.femur,servos.tibia );
        SendServos(message.legNumber, servos.coxa, servos.femur, servos.tibia);
        SendPose(message.legNumber, pose.x, pose.y, pose.z);
      }
      break;
    case MSG_TYPE_SET_POSE:  //specify next x,y,z for a leg
      {
        ik_sol_t servos;    //used as IK output here
        servos = legIK(endpoints[message.legNumber].x+message.x,  //positions are relative to the leg neutral position
        endpoints[message.legNumber].y+message.y,
        endpoints[message.legNumber].z+message.z);
        FindServoNumbers(message.legNumber);
        bioloid.setNextPose(coxaServo, servos.coxa);
        bioloid.setNextPose(femurServo, servos.femur);
        bioloid.setNextPose(tibiaServo, servos.tibia);
        SendServos(message.legNumber, servos.coxa, servos.femur, servos.tibia);
      }
      break;
    case MSG_TYPE_SET_SERVOS:
      {
        ik_sol_t servos;    //used as FK input here
        ik_req_t pose;      //used as FK output here
        servos.coxa = message.coxa;
        servos.femur = message.femur;
        servos.tibia = message.tibia;
        FindServoNumbers(message.legNumber);
        bioloid.setNextPose(coxaServo, servos.coxa);
        bioloid.setNextPose(femurServo, servos.femur);
        bioloid.setNextPose(tibiaServo, servos.tibia);
        pose = legFK(message.legNumber, servos.coxa,servos.femur,servos.tibia );
        SendPose(message.legNumber, pose.x, pose.y, pose.z);
      }
      break;
    case MSG_TYPE_MOVE:      //go to next pose
      if (lowVoltage)
      {
        ErrorMessage(LOW_VOLTAGE);
        SendVoltage();
      }
      else
      {
        bioloid.interpolateSetup(message.time);
      }
      break; 
    case MSG_TYPE_READ_REG:
      {
        int reg = ax12GetRegister(message.regReadId, message.regReadStart, message.regReadLength);
        SendReg(message.regReadStart, reg); 
      }
      break;
    case MSG_TYPE_WRITE_REG:
      ax12SetRegister(message.regWriteId, message.regWriteStart, message.regWriteL);
      break;
    case MSG_TYPE_WRITE_REG2:
      ax12SetRegister2(message.regWriteId, message.regWriteStart, (message.regWriteH << 8) + message.regWriteL);
      break;
    default:
      ErrorMessage(MSG_TYPE_UNKNOWN);
      break;
    } //end of command switch

  }
  else
  {
#ifndef NO_TIMEOUT
    if (msgTime + 2000 < millis() && axStatus == AX_WALKING)
    {
      //timeout after ~2 seconds
      Xspeed = Yspeed = Rspeed = 0;
      ErrorMessage(NOMSG_TIMEOUT);
      SendStatus(AX_STOPPING);
    } 
#endif
  }
  //interpolate as needed
  switch (axStatus)
  {
  case AX_WALKING:
    {
      if (endOfCycle)
      {
        //       SendOdo(Xspeed, Yspeed, Rspeed);
        endOfCycle = 0; 
      }
      // if our previous interpolation is complete, recompute the IK
      if(bioloid.interpolating == 0){
        if (MOVING)  //if moving
        {
          doIK();
          bioloid.interpolateSetup(tranTime);
        }
        else
        {
          SendStatus(AX_READY);
        }
      }
      // update joints
      bioloid.interpolateStep();
    }
    break;
  case AX_STOPPING:
    {
      // if our previous interpolation is complete
      if(bioloid.interpolating == 0){
        SendStatus(AX_READY);
      }
      else
      {
        // update joints
        bioloid.interpolateStep();
      }
    }
    break;

  case AX_SITTING:  //in process
    {
      // if our previous interpolation is complete, recompute the IK
      if(bioloid.interpolating == 0){
        if (endOfCycle)
        {
          gaitSelect(defaultGait);
          SendStatus(AX_TORQUED);
        }
        else
        {
          doIK();
          bioloid.interpolateSetup(tranTime);
        }
      }
      else
      {
        // update joints
        bioloid.interpolateStep();
      }
    }
    break;
  case AX_STANDING:
    {
      // if our previous interpolation is complete, recompute the IK
      if(bioloid.interpolating == 0){
        if (endOfCycle)
        {
          gaitSelect(defaultGait);
          SendStatus(AX_READY);
        }
        else
        {
          doIK();
          bioloid.interpolateSetup(tranTime);
        }
      }
      else
      {
        // update joints
        bioloid.interpolateStep();
      }
    }
    break;
  case AX_POSING:
    if (bioloid.interpolating != 0){
      bioloid.interpolateStep();
    }
    break;
  case AX_READY:
    CheckVoltage();
    break;
  default:
    break;
  }
}

// stand up slowly
void StandUp()
{
  SendStatus(AX_STANDING);
  endOfCycle = 0;
  bioloid.readPose();
  MyGaitSelect(STANDUP);
  doIK();
  bioloid.interpolateSetup(tranTime);
}
// sit down slowly
void SitDown()
{
  SendStatus(AX_SITTING);
  endOfCycle = 0;
  MyGaitSelect(SITDOWN);
  doIK();
  bioloid.interpolateSetup(tranTime);
}
//prep to stand
void TorqueOnAll()
{
  int i;
  for (i=1; i<=18; i++)
  {
    SetPosition(i, GetPosition(i));
    TorqueOn(i);
  }
  bioloid.readPose();
  SendStatus(AX_TORQUED);
}
//relax
void TorqueOffAll()
{
  int i;
  for (i=1; i<=18; i++)
  {
    Relax(i);
  }
  if (lowVoltage)
  {
    SendStatus(AX_LOWVOLTAGE);
  }
  else
  {
    SendStatus(AX_TORQUED);
  }
}
//lookup servo numbers for leg
void FindServoNumbers(char legNumber)
{
  switch (legNumber) {
  case RF:
    coxaServo  = RF_COXA;
    femurServo = RF_FEMUR;
    tibiaServo = RF_TIBIA;
    break;
  case RR:
    coxaServo  = RR_COXA;
    femurServo = RR_FEMUR;
    tibiaServo = RR_TIBIA;
    break;
  case LF:
    coxaServo  = LF_COXA;
    femurServo = LF_FEMUR;
    tibiaServo = LF_TIBIA;
    break;
  case LR:
    coxaServo  = LR_COXA;
    femurServo = LR_FEMUR;
    tibiaServo = LR_TIBIA;
    break;
  case RM:
    coxaServo  = RM_COXA;
    femurServo = RM_FEMUR;
    tibiaServo = RM_TIBIA;
    break;
  case LM:
    coxaServo  = LM_COXA;
    femurServo = LM_FEMUR;
    tibiaServo = LM_TIBIA;
    break;
  default:
#ifdef SIMPLE_COMMANDS
    Serial.print("Bad Leg#: ");
    Serial.println(legNumber);
#endif
    coxaServo  = 0;
    femurServo = 0;
    tibiaServo = 0;
    break; 
  }
}

//Communications functions

void SendAllServos()
{
  int i;
  bioloid.poseSize = 18;
  bioloid.readPose();
  for (i = 0; i<6; i++)
  {
    ik_sol_t servos;
    FindServoNumbers(i);
    servos.coxa = bioloid.getCurPose(coxaServo);
    servos.femur = bioloid.getCurPose(femurServo);
    servos.tibia = bioloid.getCurPose(tibiaServo);
    SendServos(i, servos.coxa, servos.femur, servos.tibia);
  } 
}
//send text message
void SendTextMessage(unsigned char msgType, char *textMsg)
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = msgType;
  strncpy((char*) msg.text, textMsg, TEXT_LEN);
  SendMessage(&msg);
}

//send servo out of range fail
void ServoFail(servo_enum servo, int angle)
{
#ifdef SIMPLE_COMMANDS
  Serial.print("Servo Fail: #");
  Serial.print(servo);
  Serial.print(", Angle= ");
  Serial.println(angle);
#else 
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_FAIL;
  msg.servo = servo;
  msg.angle = angle;
  SendMessage(&msg);
#endif
}

//send status report
void SendStatus(axState_enum _state)
{
  axStatus = _state;
#ifdef SIMPLE_COMMANDS
  Serial.print("Status = ");
  Serial.print(stateNames[axStatus]);
  Serial.print(" Interpolating = ");
  Serial.println(bioloid.interpolating);
#else  
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_STATUS;
  msg.state = axStatus;
  msg.lastCommand = lastCommand;
  msg.busy = (bioloid.interpolating ? 1 : 0);
  SendMessage(&msg);
#endif
}

//send leg pose
void SendPose(int legNr, int x, int y, int z)
{
#ifdef SIMPLE_COMMANDS
  Serial.print(legNr);
  Serial.print(" (");
  Serial.print(legNames[legNr]);
  Serial.print("): X= ");
  Serial.print(x);
  Serial.print(", Y= ");
  Serial.print(y);
  Serial.print(", Z= ");
  Serial.println(z);
#else 
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_POSE;
  msg.legNumber = legNr;
  msg.x = x;
  msg.y = y;
  msg.z = z;
  SendMessage(&msg);
#endif
}

//send leg servos
void SendServos(int legNr, int coxa, int femur, int tibia)
{
#ifdef SIMPLE_COMMANDS
  Serial.print(legNr);
  Serial.print(" (");
  Serial.print(legNames[legNr]);
  Serial.print("): Coxa= ");
  Serial.print(coxa);
  Serial.print(", Femur= ");
  Serial.print(femur);
  Serial.print(", Tibia= ");
  Serial.println(tibia);
#else  
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_SERVOS;
  msg.legNumber = legNr;
  msg.coxa = coxa;
  msg.femur = femur;
  msg.tibia = tibia;
  SendMessage(&msg);
#endif
}

//send reg value
void SendReg(int reg, int val)
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_REG;
  msg.ax12Reg = val;
  SendMessage(&msg);
}

void SendOdo(int x, int y, int r)
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_ODOMETRY;
  msg.xMovement = x;
  msg.yMovement = y;
  msg.zRotation = r;
  SendMessage(&msg);
}

void SendMessage(message_t *msg)
{
  int i, csum = 0;
  unsigned char *cMsg = (unsigned char *)msg;
#ifdef SIMPLE_COMMANDS
  Serial.print("Message: ");
  Serial.print(messageNames[msg->msgType]);
  for (i=0; i<MSG_INTS; i++)
  {
    Serial.print(", ");
    Serial.println(msg->intValues[i]);
  }
#else

  Serial.write(MSG_START);
  for (i=0; i<MSG_LEN; i++)
  {
    Serial.write(cMsg[i]);
    csum += cMsg[i];
  }
#ifndef NO_CRC
  Serial.write(csum & 0xff);
#endif
#endif
}

int CheckVoltage()
{
  int voltage = (ax12GetRegister (1, AX_PRESENT_VOLTAGE, 1));
#ifdef VOLT_CHECK
  if (voltage < 100)
  {
    lowVoltage = true;
  }
  else
  {
    lowVoltage = false;
  }
#endif
  return voltage;
}
//send voltage
int SendVoltage()
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  int voltage = CheckVoltage();
#ifdef SIMPLE_COMMANDS
  Serial.print("Voltage: ");
  Serial.println((float)voltage/10);
#else
  msg.msgType = MSG_TYPE_VOLTS;
  msg.volts = voltage & 0xff;
  SendMessage(&msg);
#endif
  return voltage;
}

void ErrorMessage(msgType_enum m)
{
#ifdef SIMPLE_COMMANDS
  Serial.print("Error: ");
  Serial.println(messageNames[m]);
  Serial.print("State: ");
  Serial.println(stateNames[axStatus]);
#else
  message_t msg;
  msg.msgType = MSG_TYPE_ERROR;
  msg.errorCode = (unsigned short int) m;
  msg.errorState = (unsigned short int) axStatus;
  SendMessage(&msg);
#endif
}







