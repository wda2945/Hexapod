/*
 * Partly Auto-Generated by NUKE!
 *   http://arbotix.googlecode.com
 *
 * Extensively modified by Martin to change input source
 *
 */
#define VOLT_CHECK      //halt if voltage too low
#define NO_TIMEOUT      //disable message timeout stop

#include <ctype.h>
#include "hex_msg.h"    //serial message definitions

static char *messageNames[] = DEBUG_MSG_L;
static char *stateNames[] = AX_STATE_NAMES;
static char *legNames[] = LEG_NAMES;

//added functions
void StandUp();
void SitDown();
void TorqueOnAll();
void TorqueOffAll();

//comms responses
void SendMessage(message_t *msg);
void SendTextMessage(char msgType, char *text);
void SendStatus(axState_enum _state);
void SendReg(int reg, int val);

int lowVoltage;
int CheckVoltage();
int SendVoltage();
void ErrorMessage(msgType_enum m);

axState_enum     axStatus = AX_TORQUED;
message_t        message;  //received message
msgType_enum     lastCommand = MSG_TYPE_NONE;
unsigned long    msgTime;

#define SMART_BASIC_SEL 5
#define LED_PIN 13
void setup()
{
  char volts[5];

  delay(500);

  // setup serial
  Serial.begin(38400);

  pinMode(SMART_BASIC_SEL, OUTPUT);
  digitalWrite(SMART_BASIC_SEL, HIGH);

  pinMode(LED_PIN, OUTPUT);
  
  // wait, then check the voltage (LiPO safety)
  delay (100);

  SendStatus(AX_TORQUED);
}
int CheckForMessage()
{
  // check for a whole message in the serial buffer to avoid waits
  if (Serial.available() >= MSG_LEN + 2)  //includes STX & checksum bytes
  {
    if (Serial.read() == MSG_START)    //check and skip STX
    {
      int i;
      int csum = 0;
      char c;
      unsigned char *cmsg = (unsigned char *) &message;
      for (i=0; i< MSG_LEN; i++)
      {
        //read the message
        c = Serial.read();
        cmsg[i] = c;
        csum += c;
      }
      //check checksum
      if (Serial.read() == (csum & 0xff))
      {
//        if (message.msgType < MSG_TYPE_COUNT)
//        {
//          Serial.print(messageNames[message.msgType]);
//          switch(message.msgType)
//          {
//          case MSG_TYPE_WALK:      //walk payload
//          case MSG_TYPE_BODY:      //x,y,z payload
//          case MSG_TYPE_ROTATE:    //x,y,z payload (z not used)
//            Serial.print(", x= ");
//            Serial.print(message.x);
//            Serial.print(", y= ");
//            Serial.print(message.y);
//            Serial.print(", z/r= ");
//            Serial.println(message.z);
//            break;
//          case MSG_TYPE_GAIT:      //set gait payload
//            Serial.print(", g= ");
//            Serial.println(message.x);
//            break;
//          default:
//            Serial.println();
//            break;
//          }
//        }
        return 1;
      }
      else
      {
        ErrorMessage(BAD_CHECKSUM);    //message ignored
      }
    }
  }
  return 0;
}
void loop(){
  // first take commands
  if (CheckForMessage())
  {
    msgTime = millis();
    //check for valid message context
    switch(axStatus)
    {
    case AX_RELAXED:  //torque off
      switch (message.msgType) {
      case MSG_TYPE_GETSTATUS:          
      case MSG_TYPE_GAIT:
      case MSG_TYPE_TORQUE:	  //no payload
      case MSG_TYPE_GET_POSE:  //legNumber
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_TORQUED:    //powered up - sitting down, torqued
      switch (message.msgType) {
      case MSG_TYPE_GAIT:
      case MSG_TYPE_RELAX:      
      case MSG_TYPE_STAND:     //no payload
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_POSE:      //no payload
      case MSG_TYPE_GET_POSE:  //legNumber
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        //not OK
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_READY:  //standing, ready to move
      switch (message.msgType) {
      case MSG_TYPE_GAIT:
      case MSG_TYPE_HALT:      //no payload
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_WALK:      //walk payload
      case MSG_TYPE_BODY:      //x:y:z payload
      case MSG_TYPE_ROTATE:    //x:y:z payload (z not used)
      case MSG_TYPE_SIT:        //no payload
      case MSG_TYPE_POSE:      //no payload
      case MSG_TYPE_GET_POSE:  //legNumber
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_WALKING:
      switch (message.msgType) {
      case MSG_TYPE_HALT:      //no payload
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_WALK:      //walk payload
      case MSG_TYPE_BODY:      //x:y:z payload
      case MSG_TYPE_ROTATE:    //x:y:z payload (z not used)
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_STOPPING:
    case AX_SITTING:
    case AX_STANDING:
      switch (message.msgType) {
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    case AX_POSING:
      switch (message.msgType) {
      case MSG_TYPE_HALT:      //no payload
      case MSG_TYPE_GAIT:
      case MSG_TYPE_GETSTATUS: //no payload
      case MSG_TYPE_GET_POSE:  //legNumber
      case MSG_TYPE_SET_SERVOS: //servos payload
      case MSG_TYPE_SET_POSE:  //set pose payload
      case MSG_TYPE_MOVE:      //no payload
      case MSG_TYPE_READ_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG:  //AX12 reg payload
      case MSG_TYPE_WRITE_REG2:  //AX12 reg payload (2 byte)
        //OK
        break;
      default:
        ErrorMessage(BAD_CONTEXT);
        return;
        break;
      }
      break;
    }  //end of context switch  

    //if we get here, the command can be processed
    //process the command
    switch (message.msgType) {
    case MSG_TYPE_HALT:
      if (axStatus == AX_WALKING)
      {
        SendStatus(AX_STOPPING);
      }
      else
      {
        SendStatus(AX_READY);
      }      
      break;
    case MSG_TYPE_GETSTATUS:
      SendStatus(axStatus);
      break;
    case MSG_TYPE_WALK:
      if (lowVoltage)
      {
        ErrorMessage(LOW_VOLTAGE);
        SendVoltage();
      }
      else
      {
        if (axStatus == AX_WALKING)
        {
          SendStatus(AX_STOPPING);
        }
        else
        {
          SendStatus(AX_READY);
        } 

      }
      break;
    case MSG_TYPE_BODY:    //body movement in X & Y
      break;
    case MSG_TYPE_ROTATE:  //body rotation in X, Y, & Z
      break;
    case MSG_TYPE_GAIT:
      break;
    case MSG_TYPE_TORQUE:    //servos on
      if (lowVoltage)
      {
        ErrorMessage(LOW_VOLTAGE);
        SendVoltage();
      }
      else
      {
        TorqueOnAll();
      }
      break;
    case MSG_TYPE_RELAX:    //relax servos
      TorqueOffAll();
      break;
    case MSG_TYPE_STAND:
      if (lowVoltage)
      {
        ErrorMessage(LOW_VOLTAGE);
        SendVoltage();
      }
      else
      {
        StandUp();
      }
      break;  
    case MSG_TYPE_SIT:
      SitDown();
      break;  
    case MSG_TYPE_POSEMODE:      //switch to pose mode
      SendStatus(AX_POSING);
      break; 
    case MSG_TYPE_MOVE:      //go to next pose
      if (lowVoltage)
      {
        ErrorMessage(LOW_VOLTAGE);
        SendVoltage();
      }
      break; 
    default:
      ErrorMessage(MSG_TYPE_UNKNOWN);
      break;
    } //end of command switch

  }
  else
  {
#ifndef NO_TIMEOUT
    if (msgTime + 2000 < millis() && axStatus == AX_WALKING)
    {
      //timeout after ~2 seconds
      Xspeed = Yspeed = Rspeed = 0;
      ErrorMessage(NOMSG_TIMEOUT);
      SendStatus(AX_STOPPING);
    } 
#endif
  }
  //interpolate as needed
  switch (axStatus)
  {
  case AX_WALKING:
    {
      SendStatus(AX_READY);
    }
    break;
  case AX_STOPPING:
    {
      SendStatus(AX_READY);
    }
    break;

  case AX_SITTING:  //in process
    {
      SendStatus(AX_TORQUED);
    }
    break;
  case AX_STANDING:
    {
      SendStatus(AX_READY);
    }
    break;
  case AX_POSING:
    break;
  case AX_READY:
    CheckVoltage();
    break;
  default:
    break;
  }
}

// stand up slowly
void StandUp()
{
  SendStatus(AX_STANDING);
}
// sit down slowly
void SitDown()
{
  SendStatus(AX_SITTING);
}
//prep to stand
void TorqueOnAll()
{
  SendStatus(AX_TORQUED);
}
//relax
void TorqueOffAll()
{
  if (lowVoltage)
  {
    SendStatus(AX_LOWVOLTAGE);
  }
  else
  {
    SendStatus(AX_TORQUED);
  }
}
//send text message
void SendTextMessage(unsigned char msgType, char *textMsg)
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = msgType;
  strncpy((char*) msg.text, textMsg, TEXT_LEN);
  SendMessage(&msg);
}

//send servo out of range fail
void ServoFail(servo_enum servo, int angle)
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_FAIL;
  msg.servo = servo;
  msg.angle = angle;
  SendMessage(&msg);
}

//send status report
void SendStatus(axState_enum _state)
{
  axStatus = _state;
//  Serial.print("Status = ");
//  Serial.println(stateNames[axStatus]); 
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_STATUS;
  msg.state = axStatus;
  msg.lastCommand = lastCommand;
  msg.busy = 0;
  SendMessage(&msg);
}

//send reg value
void SendReg(int reg, int val)
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  msg.msgType = MSG_TYPE_REG;
  msg.ax12Reg = val;
  SendMessage(&msg);
}

void SendMessage(message_t *msg)
{
  int i, csum = 0;
  unsigned char *cMsg = (unsigned char *)msg;
//  Serial.print("Message: ");
//  Serial.print(messageNames[msg->msgType]);
//  for (i=0; i<MSG_INTS; i++)
//  {
//    Serial.print(", ");
//    Serial.println(msg->intValues[i]);
//  }

  Serial.write(MSG_START);
  for (i=0; i<MSG_LEN; i++)
  {
    Serial.write(cMsg[i]);
    csum += cMsg[i];
  }
#ifndef NO_CRC
  Serial.write(csum & 0xff);
#endif
}

int CheckVoltage()
{
  return 13;
}
//send voltage
int SendVoltage()
{
  message_t msg;
  memset((void*) &msg, 0, MSG_LEN);
  int voltage = CheckVoltage();
//  Serial.print("Voltage: ");
//  Serial.println((float)voltage/10);

  msg.msgType = MSG_TYPE_VOLTS;
  msg.volts = voltage & 0xff;
  SendMessage(&msg);

  return voltage;
}

void ErrorMessage(msgType_enum m)
{
//  Serial.print("Error: ");
//  Serial.println(messageNames[m]);
//  Serial.print("State: ");
//  Serial.println(stateNames[axStatus]);
  message_t msg;
  msg.msgType = MSG_TYPE_ERROR;
  msg.errorCode = (unsigned short int) m;
  msg.errorState = (unsigned short int) axStatus;
  SendMessage(&msg);
}








